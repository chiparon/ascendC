第一轮工作：

1. 新建优化目录并从 baseline 完整复制：
- `Optimized/v1_shape_parallel/MatmulLeakyReluInvocation`
- `Optimized/v1_shape_parallel/MatmulLeakyReluInvocationAsync`

2. 在优化目录完成 shape 参数化（不改 baseline）：
- `main.cpp` 支持通过环境变量读取 `MATMUL_M/MATMUL_N/MATMUL_K`
- `matmul_leakyrelu_custom_tiling.cpp` 去除固定 M/N/K，改为参数传入
- `scripts/gen_data.py` 支持按环境变量生成任意 shape 数据

3. 在优化目录完成动态并行度（保守自适应）：
- `SetDim` 和 `blockDim` 不再固定常量，按 SoC 核数与 shape 估算
- 增加 `MATMUL_FORCE_CORE_NUM` 作为可控开关，便于单变量 A/B 归因

4. 运行脚本增强：
- 增加 shape/repeat 参数：`--m/--n/--k/--repeat`
- 增加时延统计输出：`AVG/P50/P90`

5. 运行状态：
- 高维 shape 在当前机器 `cpu` 路径执行耗时较长，`sim` 路径存在构建侧文件名长度错误，未完成稳定性能采样闭环。


第一轮的反思：

1：kernellaunch的优化从单一的版本开始，即合并从invocation和invocationAsync的优化版本，原因：最终工程化算子到提交时是一个结构。建议：取消其中一个优化版本，以后的开发中直接采用使用的版本。

2：关于run.sh 的启动参数 -r --cpu 与 -r --sim，是我在prompt途中错误的指引，按旧的启动传参即可（-r cpu 和 -r sim  ）如果实现了上面两个--传参，回到原来的版本即可



第一轮反思落实：

已执行落实项 1（只保留一条优化主线）：
- 执行命令（已完成）：
  - `rm -rf envtrial/samples/operator/ascendc/0_introduction/13_matmulleakyrelu_kernellaunch/Optimized/v1_shape_parallel/MatmulLeakyReluInvocation`
- 复核结果（仅保留 Async）：
  - `envtrial/.../Optimized/v1_shape_parallel/MatmulLeakyReluInvocationAsync`

已执行落实项 2（回退 run.sh 参数风格）：
- 执行动作：移除 `run.sh` 中 `-r --cpu/--sim/--npu` 兼容转换逻辑，恢复原始解析逻辑（`-r cpu|sim|npu`）。
- 目标文件：
  - `Optimized/v1_shape_parallel/MatmulLeakyReluInvocationAsync/run.sh`

参数回退验证（命令已执行）：
1. 错误形式（应失败）：
- `bash run.sh -r --cpu -v Ascend910B1`
- 输出：`[ERROR]: RUN_MODE error, This sample only support specify cpu, sim or npu!`

2. 旧形式（解析成功进入后续校验）：
- `bash run.sh -r cpu -v BadSoc`
- 输出：`[ERROR]: SOC_VERSION should be in [Ascend910B1 Ascend910B2 Ascend910B3 Ascend910B4]`
- 说明：`-r cpu` 已按旧风格被正确解析。

---

第二轮进展（按“实现路径”继续推进）：

1. 优化路径稳定性修复与 shape 覆盖
- 目录：`Optimized/v1_shape_parallel/MatmulLeakyReluInvocationAsync`
- 已完成：
  - `(512,128,512)` 在 `sim` 下可运行并精度通过；
  - 该 shape 记录为 `tiling key=1`，实际选中 `core=2 baseM=128 baseN=64`。

2. S3 A/B 性能对比（sim，repeat=5）
- Shape：`(1024,512,1024)`
- A 组（baseline-like）：`--force-core 2`
  - `AVG=117576.997 ms, P50=118120.413 ms, P90=118988.497 ms`
  - 精度：`test pass`
- B 组（optimized）：`--force-core 0`
  - `AVG=94100.600 ms, P50=94114.673 ms, P90=95085.793 ms`
  - 精度：`test pass`
- 相对提升（按 AVG）：约 `20.0%`

3. 高维 S1 现状（sim，repeat=1）
- Shape：`(2048,2048,2048)`
- `--force-core 2`：
  - 运行约 `536084 ms` 后进程异常结束（`SIGSEGV`）。
- `--force-core 0`：
  - 运行约 `184840 ms` 后进程异常结束（`SIGSEGV`）。
- 结论：当前本地 sim 环境下，S1 尚不具备稳定可采样条件，需要先做稳定性修复再进入高维性能对比。

4. CPU 路径修复与复测（补充）
- 问题：`ASCENDC_CPU_DEBUG` 路径原先固定 `blockDim=1`，在动态 tiling 下会导致仅部分输出被计算（高维下后半段为 0）。
- 修复：`main.cpp` 中 CPU 路径改为与非 CPU 路径一致，按 `tiling.usedCoreNum` 推导 `blockDim`。
- 结果：
  - `S3 (1024,512,1024)` 在 `-r cpu` 下恢复正确（`test pass`）。
  - `S1 (2048,2048,2048)` 在 `-r cpu` 下虽可启动并长时间运行，但当前环境出现大量子进程残留/回收异常，难以稳定完成一次闭环采样。

5. 当前判断（阶段内）
- M2 的“中维达标”已完成（S3 提升约 20%，且精度通过）。
- M2 的“高维稳定采样”仍受本地环境执行稳定性限制（sim/cpu 均不稳定或过慢），需转到更稳定执行环境（优先真实 NPU）继续完成 S1/S2 A/B。

---

第三轮进展（高维可执行性恢复）：

1. 自适应核心数策略收敛
- 变更：`ResolvePreferredCoreNum` 增加上限 `MATMUL_ADAPTIVE_MAX_CORE`（默认 `4`），避免高维 shape 选到过高 core 导致本地环境不稳定。
- 位置：`Optimized/v1_shape_parallel/MatmulLeakyReluInvocationAsync/main.cpp`

2. S1/S2 在 CPU 路径的可运行对比（repeat=1）
- S1 `shape=(2048,2048,2048)`：
  - `--force-core 2`：`266478.058 ms`，`test pass`
  - `--force-core 0`（现选 `core=4`）：`135694.095 ms`，`test pass`
  - 提升约：`49.1%`
- S2 `shape=(4096,1024,4096)`：
  - `--force-core 2`：`535208.601 ms`，`test pass`
  - `--force-core 0`（现选 `core=4`）：`276714.042 ms`，`test pass`
  - 提升约：`48.3%`

3. 阶段结论更新
- 在当前机器可用路径（`-r cpu`）下，S1/S2/S3 均已完成“可运行+精度通过”的 A/B 样本，并达到显著性能提升。
- 后续建议：在可用 NPU 环境复测同一配置，补齐最终提交所需硬件侧性能数据与报告附件。

---

第四轮进展（v2 稳定性修复 + NPU复测 + 口径补齐）：

1. v2 正确性修复（NPU高维错结果修复）
- 背景：`v2_try2` 中 S1/S2/S3 出现大面积误差（S4 通过）。
- 修复动作：
  - 将 `v2` kernel 中 LeakyReLU 的 in-place 路径回退为稳定的队列出入/拷回路径。
  - 文件：`Optimized/v2_algorithm/MatmulLeakyReluInvocationAsync/matmul_leakyrelu_custom.cpp`
- 结果：`v2_try3` 中 S1/S2/S3/S4 全部 `error ratio: 0.0000` 且 `test pass`。

2. 核心并行度复测（NPU, Ascend910B3）
- `v2_try3_coresweep.md` 结论：
  - `core=1`：被 fail-fast 拦截（910B 单核路径禁用）
  - `core=6`：常回退到 `usedCore=4`（tiling合法性约束导致）
  - `S2/S3` 当前稳定最优倾向为 `force-core=4`
- `v2_try3_corecompare.md` 有效对比：
  - `S3`: core2 `5388.969 ms` -> core4 `5325.287 ms`（约 `+1.18%`）
  - `S2`: core2 `5810.810 ms` -> core4 `5386.045 ms`（约 `+7.31%`）
  - 精度均通过。

3. 性能口径补齐（本轮关键）
- 问题：端到端 `PERF` 时间在不同 shape 都集中在 5~6s，固定开销占比高，不利于评估 kernel 优化收益。
- 动作：在 `run.sh` 保留原 `PERF` 的同时，新增可选 kernel msprof 采集：
  - `--kernel-msprof`
  - `--msprof-repeat`
  - `--msprof-output`
- 文件：`Optimized/v2_algorithm/MatmulLeakyReluInvocationAsync/run.sh`
- 目的：并行记录“总耗时 + kernel耗时”，用于后续 M2 调优归因。

4. 阶段判断
- 正确性：已恢复并稳定。
- 性能：NPU 高维增益目前未达到 `>=20%`（M2 尚未达标）。
- 过程状态：按要求暂停继续验证推进，待后续恢复时以 msprof kernel-time 主导下一轮优化。

5. 防偏移约束（后续会话优先参考）
- 目标与评分约束：`/home/viparon/share/VMShare/AIal/要求/leakyrelu`
- 实现路径里程碑：`/home/viparon/share/VMShare/AIal/要求/实现路径.md`
- 最新有效结果：
  - `/home/viparon/share/VMShare/AIal/kernel_results/v2_try3_corecompare.md`
  - `/home/viparon/share/VMShare/AIal/kernel_results/v2_try3_coresweep.md`
  - `/home/viparon/share/VMShare/AIal/kernel_results/v2_try3.md`

---

第五轮进展（恢复推进：单变量调参闭环能力补齐）：

1. v2 tiling 增加 baseM/baseN 强制入口（默认行为不变）
- 变更文件：
  - `Optimized/v2_algorithm/MatmulLeakyReluInvocationAsync/matmul_leakyrelu_custom_tiling.cpp`
- 新增环境变量：
  - `MATMUL_FORCE_BASE_M`
  - `MATMUL_FORCE_BASE_N`
- 行为：
  - 当两个变量均 >0 时，将该 `(baseM, baseN)` 插入 split 搜索首位；
  - 保持原 shape-key 候选顺序与合法性校验，不合法组合自动跳过；
  - 增加候选去重，保证日志与调参复现的一致性。

2. run.sh 补充 CLI 参数，支持单变量实验
- 变更文件：
  - `Optimized/v2_algorithm/MatmulLeakyReluInvocationAsync/run.sh`
- 新增参数：
  - `--force-base-m`（短参 `-M`）
  - `--force-base-n`（短参 `-N`）
- 导出：
  - `MATMUL_FORCE_BASE_M`
  - `MATMUL_FORCE_BASE_N`
- 作用：可在不改代码前提下，直接在同一二进制上进行 baseM/baseN A/B。

3. 新增 NPU+msprof 扫描脚本（M2 主线）
- 新增文件：
  - `Optimized/v2_algorithm/MatmulLeakyReluInvocationAsync/scripts/run_kernel_tune.sh`
- 脚本能力：
  - 先 build-once，再按 `force-core x baseM x baseN` 网格扫描；
  - 覆盖 S2/S1/S3（高维优先）；
  - 每次运行启用 `--kernel-msprof`，并将每个 case 的 msprof 输出目录独立保存；
  - 同时汇总 `PERF AVG/P50/P90 + error ratio + pass/fail` 到 `summary.csv/summary.md`。

4. 建议执行方式（NPU）
```bash
cd /home/viparon/share/VMShare/AIal/envtrial/samples/operator/ascendc/0_introduction/13_matmulleakyrelu_kernellaunch/Optimized/v2_algorithm/MatmulLeakyReluInvocationAsync

# 默认扫描 core={2,4}, baseM={128,256}, baseN={128,256}
RUN_MODE=npu SOC_VERSION=Ascend910B3 DO_BUILD=1 REPEAT=1 MSPROF_REPEAT=1 \
  bash scripts/run_kernel_tune.sh

# 可选：缩小搜索空间做快速回归
FORCE_CORE_LIST="4" BASE_M_LIST="128 256" BASE_N_LIST="128" \
RUN_MODE=npu SOC_VERSION=Ascend910B3 DO_BUILD=0 REPEAT=1 MSPROF_REPEAT=1 \
  bash scripts/run_kernel_tune.sh
```

5. 当前阶段结论
- 已从“可采集 msprof”推进到“可批量、可归因、可复现”的单变量调参闭环；
- 下一步按 `summary.csv + msprof 子目录` 做 S1/S2 的 kernel-time 排序，锁定候选并回灌默认 shape 策略（目标：推进 M2 达标）。

