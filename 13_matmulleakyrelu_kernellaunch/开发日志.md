第一轮工作：

1. 新建优化目录并从 baseline 完整复制：
- `Optimized/v1_shape_parallel/MatmulLeakyReluInvocation`
- `Optimized/v1_shape_parallel/MatmulLeakyReluInvocationAsync`

2. 在优化目录完成 shape 参数化（不改 baseline）：
- `main.cpp` 支持通过环境变量读取 `MATMUL_M/MATMUL_N/MATMUL_K`
- `matmul_leakyrelu_custom_tiling.cpp` 去除固定 M/N/K，改为参数传入
- `scripts/gen_data.py` 支持按环境变量生成任意 shape 数据

3. 在优化目录完成动态并行度（保守自适应）：
- `SetDim` 和 `blockDim` 不再固定常量，按 SoC 核数与 shape 估算
- 增加 `MATMUL_FORCE_CORE_NUM` 作为可控开关，便于单变量 A/B 归因

4. 运行脚本增强：
- 增加 shape/repeat 参数：`--m/--n/--k/--repeat`
- 增加时延统计输出：`AVG/P50/P90`

5. 运行状态：
- 高维 shape 在当前机器 `cpu` 路径执行耗时较长，`sim` 路径存在构建侧文件名长度错误，未完成稳定性能采样闭环。


第一轮的反思：

1：kernellaunch的优化从单一的版本开始，即合并从invocation和invocationAsync的优化版本，原因：最终工程化算子到提交时是一个结构。建议：取消其中一个优化版本，以后的开发中直接采用使用的版本。

2：关于run.sh 的启动参数 -r --cpu 与 -r --sim，是我在prompt途中错误的指引，按旧的启动传参即可（-r cpu 和 -r sim  ）如果实现了上面两个--传参，回到原来的版本即可



第一轮反思落实：

已执行落实项 1（只保留一条优化主线）：
- 执行命令（已完成）：
  - `rm -rf envtrial/samples/operator/ascendc/0_introduction/13_matmulleakyrelu_kernellaunch/Optimized/v1_shape_parallel/MatmulLeakyReluInvocation`
- 复核结果（仅保留 Async）：
  - `envtrial/.../Optimized/v1_shape_parallel/MatmulLeakyReluInvocationAsync`

已执行落实项 2（回退 run.sh 参数风格）：
- 执行动作：移除 `run.sh` 中 `-r --cpu/--sim/--npu` 兼容转换逻辑，恢复原始解析逻辑（`-r cpu|sim|npu`）。
- 目标文件：
  - `Optimized/v1_shape_parallel/MatmulLeakyReluInvocationAsync/run.sh`

参数回退验证（命令已执行）：
1. 错误形式（应失败）：
- `bash run.sh -r --cpu -v Ascend910B1`
- 输出：`[ERROR]: RUN_MODE error, This sample only support specify cpu, sim or npu!`

2. 旧形式（解析成功进入后续校验）：
- `bash run.sh -r cpu -v BadSoc`
- 输出：`[ERROR]: SOC_VERSION should be in [Ascend910B1 Ascend910B2 Ascend910B3 Ascend910B4]`
- 说明：`-r cpu` 已按旧风格被正确解析。

---

第二轮进展（按“实现路径”继续推进）：

1. 优化路径稳定性修复与 shape 覆盖
- 目录：`Optimized/v1_shape_parallel/MatmulLeakyReluInvocationAsync`
- 已完成：
  - `(512,128,512)` 在 `sim` 下可运行并精度通过；
  - 该 shape 记录为 `tiling key=1`，实际选中 `core=2 baseM=128 baseN=64`。

2. S3 A/B 性能对比（sim，repeat=5）
- Shape：`(1024,512,1024)`
- A 组（baseline-like）：`--force-core 2`
  - `AVG=117576.997 ms, P50=118120.413 ms, P90=118988.497 ms`
  - 精度：`test pass`
- B 组（optimized）：`--force-core 0`
  - `AVG=94100.600 ms, P50=94114.673 ms, P90=95085.793 ms`
  - 精度：`test pass`
- 相对提升（按 AVG）：约 `20.0%`

3. 高维 S1 现状（sim，repeat=1）
- Shape：`(2048,2048,2048)`
- `--force-core 2`：
  - 运行约 `536084 ms` 后进程异常结束（`SIGSEGV`）。
- `--force-core 0`：
  - 运行约 `184840 ms` 后进程异常结束（`SIGSEGV`）。
- 结论：当前本地 sim 环境下，S1 尚不具备稳定可采样条件，需要先做稳定性修复再进入高维性能对比。

4. CPU 路径修复与复测（补充）
- 问题：`ASCENDC_CPU_DEBUG` 路径原先固定 `blockDim=1`，在动态 tiling 下会导致仅部分输出被计算（高维下后半段为 0）。
- 修复：`main.cpp` 中 CPU 路径改为与非 CPU 路径一致，按 `tiling.usedCoreNum` 推导 `blockDim`。
- 结果：
  - `S3 (1024,512,1024)` 在 `-r cpu` 下恢复正确（`test pass`）。
  - `S1 (2048,2048,2048)` 在 `-r cpu` 下虽可启动并长时间运行，但当前环境出现大量子进程残留/回收异常，难以稳定完成一次闭环采样。

5. 当前判断（阶段内）
- M2 的“中维达标”已完成（S3 提升约 20%，且精度通过）。
- M2 的“高维稳定采样”仍受本地环境执行稳定性限制（sim/cpu 均不稳定或过慢），需转到更稳定执行环境（优先真实 NPU）继续完成 S1/S2 A/B。

---

第三轮进展（高维可执行性恢复）：

1. 自适应核心数策略收敛
- 变更：`ResolvePreferredCoreNum` 增加上限 `MATMUL_ADAPTIVE_MAX_CORE`（默认 `4`），避免高维 shape 选到过高 core 导致本地环境不稳定。
- 位置：`Optimized/v1_shape_parallel/MatmulLeakyReluInvocationAsync/main.cpp`

2. S1/S2 在 CPU 路径的可运行对比（repeat=1）
- S1 `shape=(2048,2048,2048)`：
  - `--force-core 2`：`266478.058 ms`，`test pass`
  - `--force-core 0`（现选 `core=4`）：`135694.095 ms`，`test pass`
  - 提升约：`49.1%`
- S2 `shape=(4096,1024,4096)`：
  - `--force-core 2`：`535208.601 ms`，`test pass`
  - `--force-core 0`（现选 `core=4`）：`276714.042 ms`，`test pass`
  - 提升约：`48.3%`

3. 阶段结论更新
- 在当前机器可用路径（`-r cpu`）下，S1/S2/S3 均已完成“可运行+精度通过”的 A/B 样本，并达到显著性能提升。
- 后续建议：在可用 NPU 环境复测同一配置，补齐最终提交所需硬件侧性能数据与报告附件。

